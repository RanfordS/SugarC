~@> Summary of Goals


Consistent naming convention
e.g. all types use PascalCase

Custom operators
e.g. `Infix Float: (Vec: a) dot (Vec: b)`

Implict type continuation
e.g. `Vec: swap (v, Int: i, j)`

Pointer declarations that are easier to understand
e.g. `int *const a` -> `Const &Int: a`


~@> Declarations

?modifiers type: name;

~> Examples

> C

const int *a;                   // pointer to constant int
int *const b;                   // constant pointer to int
const int *const c;             // constant pointer to constant int
int d = *b;                     // d = the value at address b
int* e = &d;                    // e = pointer to address of d

Vec3* v;
float x = v->x;                 // `->` adds offset of and dereferences
float* px = &v->x;

struct SomeStruct* structure;
int val = *structure->ptr;

double values[n];



int main (int argc, char **argv)
{
    return 0;
}



void qsort (void* base, size_t nitems, size_t size, int (*compar)(const void*, const void*);

int cmpfunc (const void* a, const void* b)
{
    return *(int*)a - *(int*)b;
}

#define ISLETTER(c) (('A' <= (c) && 'Z' <= (c)) || ('a' <= (c) && 'z' <= (c)))

int a;
float b = 1.0f + *(float*)(void*)(&a);



> SugarC

&Const Int: a;                  // pointer to constant int
Const &Int: b;                  // constant pointer to int
Const &Const Int: c;            // constant pointer to constant int
Int: d = @b;                    // d = the value at address b
&Int: e = &d;                   // e = pointer to address of d

&Vec3: v;
Float: x = v.x;                 // `.` for pointers equivalent to C `->`
&Float: px = &v.x;

&SomeStruct: structure;
Int: val = @structure.ptr       // @ dereferences `ptr`, not `structure`

Array[n] Double: values;
SomeStruct Array[n]: soa;       // structure of arrays declaration?



Function Int: main (argc, &&Char: argv)
{
    return 0;
}



Void: qsort (&Void: base, Size: nitem, size, Function Int: compar (&Const Void: a, b));

Function Int: cmpfunc (&Const Void: a, b)
{
    return @(&Int: a) - @(&Int: b);
}

Macro: ISLETTER (c) {('A' <= (c) <= 'Z' || 'a' <= (c) <= 'z')}

Int: a;
Float: b = 1.0f + (!Float: a);



~@> Sugar Example

Sugar: max (a, b)
{
    if (a < b)
        return b;
    return a;
}

Sugar: min (a, b)
{
    if (a < b)
        return a;
    return b;
}

Prefix Sugar: not (a)
{
    return !a;
}

// short-circuit and/or

Infix Sugar: (a) and (b)
{
    if (a)
        return b;
    return a;
}

Infix Sugar: (a) or (b)
{
    if (!a)
        return b;
    return a;
}

// adding `b;` at the top of either function body will disable the short-circuit



~@> Possible Loop declarations

// standard C-style for loop
for (Size: i = 0; i < n; ++i) { ... }

// optional range version
for (Size: i = 0 -> n) { ... }

// range implicitly starts at 0
for (Size: i -> n) { ... }

// default type for undeclared variables is same a range end?
for (i -> n) { ... }



~@> Standard Types

Bool    (i1)
Char    (i8)
Byte    (i8)
Int     (i32)   { Both Int and UInt may be followed by any compile time number
UInt    (i32)     If non is provided, 32 is used as the default                }
Size    (i64)   { equivalent to size_t, i64 should always satisfy the standard }
Half    (half)
Float   (float)
Double  (double)
Void
Function

Enum
BitField      { Acts like Enum, but members are numbered according to (1 << i) }

~@> Standard Modifiers

Volatile
Restrict
Align8 Align16 Align32 Align64
Const
Atomic
Extern
Inline
Prefix Infix Suffix  { Custom operator declarations }
Macro                { Used instead of #define }
Sugar                { Full body function-style macros, supports short-circuit }

~@> Control Flow Keywords

switch
    case
    default
    break
do while for
    continue
    break
if else
goto label
return

~@> Operators

Category:
    Name            Symbol  Assignment

Arithmetic:
    Unary plus      +$
    Unary minus     -$
    Assignment      $=$
    Addition        $+$     $+=$
    Subtraction     $-$     $-=$
    Multiplication  $*$     $*=$
    Division        $/$     $/=$
    Modulus         $%$     $%=$
    Preincrement    ++$
    Postincrement   $++
    Predecrement    --$
    Postdecrement   $--

Comparitive:
    Equality        $==$
    Inequality      $!=$
    Greater than    $>$
      or equal to   $>=$
    Less than       $<$
      or equal to   $<=$

Logical:
    Not             !$
    And             $&&$    $&&=$
    Or              $||$    $||=$
    Xor             $^^$    $^^=$

Bitwise:
    Not             ~$
    And             $&$     $&=$
    Or              $|$     $|=$
    Xor             $^$     $^=$
    Shift left      $<<$    $<<=$
    Shift right     $>>$    $>>=$

Pointer Ops:
    Index           $[$]
    Member of       $.$
    Address of      &$
    At address      @$

Other:
    Function call   $($)
    Ternary         $?$:$
    Cast            ($:$)
    Reinterpret     (!$:$)
    End statement   $;

By Priority:
->   $++ $-- $($) $[$] $.$
<-   ++$ --$ +$ -$ !$ ~$ @$ &$
->   $*$ $/$ $%$
->   $+$ $-$
->   $<<$ $>>$
->   $<$ $<=$ $>$ $>=$
->   $==$ $!=$
->   $&$
->   $^$
->   $|$
->   $&&$
->   $^^$
->   $||$
<-   $?$:$
<-   $=$ $+=$ $-=$ $*=$ $/=$ $%=$ $<<=$ $>>=$ $&=$ $^=$ $|=$
->   $,$



~@> Parsing

// minimal file
Int: main (argc, &&Char: argv)
{
    printf ("Hello\n");
    return 0;
}

-> generalizer parse -> { delimiter errors }

comment
noun op noun bracket noun op op op noun op noun bracket
bracket
    noun bracket string bracket op
    noun number op
bracket

-> bracketing parse -> { missmatching brackets }

</file
    comment
    noun op noun
    </()
        noun op op op noun op noun
    />
    </{}
        noun </() string /> op
        noun number op
    />
/>

-> statement parse ->

</file
    <comment>
    </decl
        </name
            noun op noun
        />
        </args
            <noun>
            <noun op noun>
        />
        </body
            <noun </() string />>
            <noun number>
        />
    />
/>

-> context parse ->

</file
    <comment>
    </decl
        </type Int/>
        </name main/>
        </args
            <</type Int/> </name argc/>>
            <</type &&Char/> </name argv/>>
        />
        </body
            </call
                </name printf/>
                </args
                    <</type String/> </literal "Hello\n"/>>
                />
            />
            </return
                </type Int/> </literal 0/>
            />
        />
    />
/>
